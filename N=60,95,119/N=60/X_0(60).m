load "quadptssieve.m";
load "ozmansiksek_TorsHelp.m";
load "X0N_NiceModel.m";
load "HelpTorsion.m";

//we find models for X0(60) and X0(60)/w15

C:=CuspForms(60);
"Dimension of CuspForms(60) is:";
Dimension(C);

AL15:=AtkinLehnerOperator(C, 15);
N15:=Nullspace(Matrix(AL15 - 1));

"Dimesion of eigenspace lambda=1 for w15 is:";
Dimension(N15);

N15c:=Nullspace(Matrix(AL15 + 1));

"Dimesion of eigenspace lambda=-1 for w15 is:";
Dimension(N15c);

B15:=[&+[(Integers()!(2*Eltseq(Basis(N15)[i])[j]))*C.j : j in [1..Dimension(C)]] : i in [1..Dimension(N15)]];
B15c:=[&+[(Integers()!(2*Eltseq(Basis(N15c)[i])[j]))*C.j : j in [1..Dimension(C)]] : i in [1..Dimension(N15c)]];

X60,jMap:= modformeqns(B15c cat B15, 60, 500, 20);
"Model for X0(60) is:";
X60;
"";
RR<[u]>:=CoordinateRing(AmbientSpace(X60));
n:=Dimension(AmbientSpace(X60));

H:=Matrix(RationalField(), 7, 7, [1,0,0,0,0,0,0, 0,1,0,0,0,0,0, 0,0,1,0,0,0,0, 0,0,0,1,0,0,0, 0,0,0,0,1,0,0, 0,0,0,0,0,1,0, 0,0,0,0,0,0,-1]);
rows:=[[&+[RowSequence(H)[i][j]*u[j] : j in [1..n+1]] : i in [1..n+1]]] ;
w15:=iso<X60->X60 | rows, rows>;
"w15 on X0(60) is given by:";
w15;
"";

X60w15,quotMap15:=CurveQuotient(AutomorphismGroup(X60,[w15]));
"Genus of X0(60) is ", Genus(X60);
"Genus of X0(60)/w15 is ", Genus(X60w15);
"";

//P1, ..., P12 are cusps
P1:=X60![0,0,0,0,-1,0,1];
P2:=X60![0,0,0,0,1,0,1];
P3:=X60![0,0,-1/4,-1/4,1/4,1/4,1];
P4:=X60![0,0,-1/4,1/4,1/4,-1/4,1];
P5:=X60![0,0,1/4,-1/4,-1/4,1/4,1];
P6:=X60![0,0,1/4,1/4,-1/4,-1/4,1];
P7:=X60![-1,0,0,0,0,0,1];
P8:=X60![-1/2,-1/2,-1/4,-1/4,-1/4,-1/4,1];
P9:=X60![-1/2,1/2,-1/4,1/4,-1/4,1/4,1];
P10:=X60![1/2,-1/2,1/4,-1/4,1/4,-1/4,1];
P11:=X60![1/2,1/2,1/4,1/4,1/4,1/4,1];
P12:=X60![1,0,0,0,0,0,1];

"By finding poles of j-map, we find that we have these 12 cusps (P1, ..., P12):";
Poles(jMap);
"";

"Cuspidal group is generated by Di := P1 - Pi, i in {2,3, ..., 12}";
"";

D2:=Divisor(P1)-Divisor(P2);
D3:=Divisor(P1)-Divisor(P3);
D4:=Divisor(P1)-Divisor(P4);
D5:=Divisor(P1)-Divisor(P5);
D6:=Divisor(P1)-Divisor(P6);
D7:=Divisor(P1)-Divisor(P7);
D8:=Divisor(P1)-Divisor(P8);
D9:=Divisor(P1)-Divisor(P9);
D10:=Divisor(P1)-Divisor(P10);
D11:=Divisor(P1)-Divisor(P11);
D12:=Divisor(P1)-Divisor(P12);

// this shows that D2 and D3 are of order 24 and independent
// hence, they generate subgroup Z/24Z + Z/24Z
b,ff := IsPrincipal(24*D2);
"Is D2 of order 24?";
b and not(IsPrincipal(8*D2) or IsPrincipal(12*D2));
"";

"Is D3 of order 24?";
b,ff := IsPrincipal(24*D3);
b and not(IsPrincipal(8*D2) or IsPrincipal(12*D2));
"";

"Is a*D2 = b*D3 while (a,b)!=(0,0) mod 24? (are D2 and D3 linearly dependent?)";
AreDependent(D2,D3,24), ", hence, D2 and D3 generate subgroup iso. to (Z/24Z)^2";
"";

//D2 and D3 generate the following subgroup
G:=[i*D2+j*D3 : i in [-11..12], j in [-11..12]];

// this shows that D5 is of order 24 in torsion group, but also of
// order 24 (coset) in quotient J(60)(Q)_tor/<D2, D3>, hence D5 gives another
// Z/24Z component in J(60)(Q)_tor
b, ff:=IsPrincipal(24*D5);
"Is D5 of order 24?";
b and not (IsPrincipal(12*D5) or IsPrincipal(8*D5));
"";

"Is coset of D5 of order 24 in J(60)(Q)_tor/<D2, D3>?";
not(IsInGroup(12*D5, G) or IsInGroup(8*D5, G)), ", hence, we know that D2, D3, D5 generate a subgroup (Z/24Z)^3";
"";

//Getting the Z/4Z part
D7:=Divisor(P1)-Divisor(P7);
Dt:=D7-4*D2-6*D3;

//Dt is of order 4
b, ff := IsPrincipal(4*Dt);
"Is Dt := D7 - 4*D2 - 6*D3 of order 4?";
b and not (IsPrincipal(2*Dt));
"";

// 2*Dt is of order 2, but 2*Dt and 2*Dt+12*D5 are both not in <D2,D3>
// hence, (coset of) 2*Dt is of order 2 in J(60)(Q)_tor/<D2,D3,D5>
// hence, (coset of) Dt is of order 4 in J(60)(Q)_tor/<D2,D3,D5> so
// Dt gives uz new Z/4Z component

"Is coset of Dt of order 4 in J(60)(Q)_tor/<D2,D3,D5>?";
not(IsInGroup(2*Dt, G) or IsInGroup(2*Dt+12*D5, G));
"Hence we have proven that Dt, D5, D3, D2 generate a subgroup Z/4Z + (Z/24Z)^3";
"";

TOR:=[i*D2 + j*D3 + k*D5 + l*Dt : i in [-11..12], j in [-11..12], k in [-11..12], l in [-1..2]];

//an explicit but slow bulletproof check that TOR has no duplicates, although the above arguments prove that fact
/*
"";
"If some two different divisors in TOR are equivalent, TOR will have more than one principal divisor";
"because their difference is also in TOR";
"Hence if TOR has only one principal divisor, TOR is really without duplicates";
"";
"Found ", CheckDuplicates(TOR), " principal divisors in TOR";
"";
*/

"Now we prove that J0(60)(Q)_tors == Z/4Z + (Z/24Z)^3";
"";

//known degree 1 places
pls1 := [Place(P1), Place(P2), Place(P3), Place(P4), Place(P5), Place(P6), Place(P7), Place(P8), Place(P9), Place(P10), Place(P11), Place(P12)];

//we use Ozman, Siksek code to help us in determining torsion
hom, Ksub, bas, divsReturned := findGenerators(X60, pls1, Place(P1), 7);
"By Ozman, Siksek, cuspidal subgroup is isomorphic to:";
Ksub, "(same as we got from our computations)";
"";

"J0(60)(Q)_tors is isomorphic to one of the following groups:";
"";
homs:=possibleJList(X60, divsReturned, Place(P1), Ksub, bas, [7, 11]);

possibleGroups := [];
for i in [1..#homs] do
	possibleGroups:=Append(possibleGroups, Codomain(homs[i]));
end for;
Seqset(possibleGroups);
"";

//now we use reduction mod 23 to finally determine J0(60)(Q)
X_23 := ChangeRing(X60, GF(23));
CG, phi, psi := ClassGroup(X_23);
Z := FreeAbelianGroup(1);
degr := hom<CG->Z | [ Degree(phi(a))*Z.1 : a in OrderedGenerators(CG)]>;
JF23 := Kernel(degr); // This is isomorphic to J_0(60)(\F_23).
"J(F23) is iso to:";
JF23;
"";
"This shows that J0(60)(Q)_tors can't have an element of order 48.";
"By the previous information and with rk(J0(60)(Q)) = 0, we conclude J0(60)(Q) == Z/4Z + (Z/24Z)^3";
"";

//known degree 2 places (conjecture is that there are no quadratic points that are not pullbacks)
pls2:=[];

deg2:=[];
deg2pb:=[];

for i in [1..#pls1] do
	for j in [i..#pls1] do
		deg2:=Append(deg2, 1*pls1[i] + 1*pls1[j]);
		if w15(RepresentativePoint(pls1[i])) eq RepresentativePoint(pls1[j]) then
			deg2pb:=Append(deg2pb, 1*pls1[i] + 1*pls1[j]);
		end if;
	end for;
end for;

deg2npb:=[DD : DD in deg2 | not DD in deg2pb];

"We have found ", #deg2, " points on X_0(60)^2(Q).";
#deg2pb, "of them are pullbacks of rationals from X0(60)/w15.";
#deg2npb, "of them are non-pullbacks";

//Finally, we do the sieve.
A := AbelianGroup([4, 24, 24, 24]);
divs := [Dt, D2, D3, D5];
genusC := Genus(X60w15);
auts := [H];
bp := deg2pb[1];

//divs == A == J(60)(Q)_tors, hence I = 1
I:=1;

primes := [13];

bret := MWSieve(deg2, primes, X60, A, divs, auts, genusC, deg2pb, deg2npb, I, bp);
"Succeeded in proving that we have found all exceptional quadratic pts? (true if succeeded, number otherwise)";
bret;
assert bret eq true;

"Hence, there are no quadratic points on X0(60) not coming from X0(60)/w15(Q).";
"We now have to find rational points on X0(60)/w15(Q) and check their pullbacks.";
"";

E,eMap:=EllipticCurve(X60w15, quotMap15(X60![0,0,0,0,-1,0,1]));
XtoE:=quotMap15*eMap;

"X0(60)/w15(Q) is actually the following elliptic curve E/Q:";
E;
"";

rk, provable := Rank(E);
assert provable;

"It has rank", rk;
"Notice that this shows that rk(J0(60)(Q)) == rk(J(C)(Q)).";
"";

grp, mpg := TorsionSubgroup(E);
"Its torsion is:";
grp;
"";

pts:=Points(E:Bound:=100);
assert #pts eq #grp;

"Here are all rational points on E:";
pts;
"";

for i in [1..#pts] do
	"Pullback of point ", pts[i], " is:";
	Decomposition(Pullback(XtoE, Place(pts[i])));
	"";
end for;

"Hence, there are no new quadratic points on X0(60) coming from X0(60)/w15(Q).";
